<!DOCTYPE html>
<html>
<head>
    <title>Painel Admin - Rally Pro</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <style>
        body { font-family: sans-serif; margin: 0; }
        #map { height: calc(100vh - 100px); width: 100%; }
        .controls { padding: 15px; background: #2c3e50; color: white; display: flex; gap: 10px; align-items: center; }
        .car-icon { background: white; border: 2px solid black; border-radius: 50%; text-align: center; font-weight: bold; line-height: 20px; }
    </style>
</head>
<body>
    <div class="controls">
        <input type="text" id="citySearch" placeholder="Cidade...">
        <button onclick="changeMapMode()">ğŸ›°ï¸ SatÃ©lite</button>
        <button onclick="saveConfig()" style="background: #27ae60; color: white;">ğŸ’¾ Salvar Mapa</button>
        <button onclick="apurarResultados()" style="background: #e67e22; color: white;">ğŸ Finalizar e Apurar</button>
        <button onclick="resetProva()" style="background: #c0392b; color: white;">ğŸ§¹ Resetar</button>
        <button onclick="window.location.href='resultados.html'">ğŸ“Š Ranking</button>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.all.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getDatabase, ref, set, onValue, get, update, remove } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBPJkehV9C1x0hiY5dQSwSRtVf5c4P2JGE",
            authDomain: "cronometro-rally.firebaseapp.com",
            databaseURL: "https://cronometro-rally-default-rtdb.firebaseio.com",
            projectId: "cronometro-rally",
            storageBucket: "cronometro-rally.firebasestorage.app",
            messagingSenderId: "341731891354",
            appId: "1:341731891354:web:d0c34265be68015e98a723"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- INICIALIZAÃ‡ÃƒO DO MAPA ---
        const map = L.map('map').setView([-23.55, -46.63], 13);
        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
        const sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}');
        
        const drawnItems = new L.FeatureGroup().addTo(map);
        const drawControl = new L.Control.Draw({
            edit: { featureGroup: drawnItems },
            draw: { polygon: false, marker: false, circlemarker: false, 
                    polyline: { title: 'Desenhar Percurso' },
                    rectangle: { title: 'Radar de Velocidade' },
                    circle: { title: 'Waypoint' } }
        });
        map.addControl(drawControl);

        // Captura desenhos e solicita velocidade
        map.on(L.Draw.Event.CREATED, (e) => {
            const layer = e.layer;
            if (e.layerType === 'rectangle') {
                layer.options.speedLimit = prompt("Velocidade MÃ¡xima (km/h):", "60");
                layer.bindPopup("Radar: " + layer.options.speedLimit + "km/h");
            }
            if (e.layerType === 'circle') {
                layer.bindPopup("Waypoint");
            }
            drawnItems.addLayer(layer);
        });

        // --- FUNÃ‡Ã•ES DE INTERFACE ---
        window.changeMapMode = () => map.hasLayer(osm) ? (map.removeLayer(osm), sat.addTo(map)) : (map.removeLayer(sat), osm.addTo(map));

        window.saveConfig = async () => {
            const geojson = drawnItems.toGeoJSON();
            // Injetar propriedades extras que o toGeoJSON nativo perde (raio e limite vel)
            geojson.features.forEach((feature, i) => {
                const layer = Object.values(drawnItems._layers)[i];
                if(layer instanceof L.Circle) feature.properties.radius = layer.getRadius();
                if(layer.options.speedLimit) feature.properties.speedLimit = layer.options.speedLimit;
            });
            await set(ref(db, 'config'), geojson);
            alert("ConfiguraÃ§Ã£o de prova salva!");
        };

        // --- LÃ“GICA DE APURAÃ‡ÃƒO (O CÃ‰REBRO DO SISTEMA) ---
        window.apurarResultados = async () => {
            const configSnap = await get(ref(db, 'config'));
            const competidoresSnap = await get(ref(db, 'competidores'));
            const historicoSnap = await get(ref(db, 'historico'));

            if (!configSnap.exists() || !competidoresSnap.exists()) return alert("Dados insuficientes.");

            const config = configSnap.val();
            const competidores = competidoresSnap.val();
            const historicos = historicoSnap.val();

            for (let id in competidores) {
                let pontosPerdidos = 0;
                const rastro = Object.values(historicos[id] || {});
                const waypointsCheck = config.features.filter(f => f.geometry.type === "Point" && f.properties.radius);
                const radares = config.features.filter(f => f.geometry.type === "Polygon" && f.properties.speedLimit);
                
                let waypointsVisitados = new Set();

                rastro.forEach(pos => {
                    const pt = turf.point([pos.lng, pos.lat]);

                    // 1. Checar Radares (RetÃ¢ngulos)
                    radares.forEach(radar => {
                        const poly = turf.polygon(radar.geometry.coordinates);
                        if (turf.booleanPointInPolygon(pt, poly)) {
                            if (pos.vel > parseFloat(radar.properties.speedLimit)) {
                                pontosPerdidos += 1000; // Penalidade por excesso de velocidade
                            }
                        }
                    });

                    // 2. Checar Waypoints (CÃ­rculos)
                    waypointsCheck.forEach((wp, idx) => {
                        const center = [wp.geometry.coordinates[0], wp.geometry.coordinates[1]];
                        const distance = turf.distance(pt, turf.point(center), {units: 'meters'});
                        if (distance <= wp.properties.radius) {
                            waypointsVisitados.add(idx);
                        }
                    });
                });

                // Penalizar Waypoints nÃ£o visitados
                const naoVisitados = waypointsCheck.length - waypointsVisitados.size;
                pontosPerdidos += (naoVisitados * 1000);

                // Atualizar Firebase
                const pontosFinais = 150000 - pontosPerdidos;
                await update(ref(db, `competidores/${id}`), {
                    pontosPerdidos,
                    pontos: pontosFinais
                });
            }
            alert("ApuraÃ§Ã£o concluÃ­da! Verifique o ranking.");
        };

        window.resetProva = () => {
            if(confirm("Apagar todos os dados de competidores e histÃ³rico?")) {
                remove(ref(db, 'competidores'));
                remove(ref(db, 'historico'));
                location.reload();
            }
        };

        // Monitoramento em tempo real (Ãcones com nÃºmeros)
        onValue(ref(db, 'competidores'), (snap) => {
            const data = snap.val();
            for(let id in data) {
                const c = data[id];
                const pos = [c.lat, c.lng];
                const icon = L.divIcon({ className: 'car-icon', html: c.numero, iconSize: [25, 25] });
                // LÃ³gica de atualizar/criar marker...
            }
        });
    </script>
</body>
</html>
